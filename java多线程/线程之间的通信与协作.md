[TOC]

# 线程之间的通信与协作

### 多线程基本概念

**1.进程**

进程是**操作系统**进行资源分配和调度的基本单位。

**2.线程**

线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。

**3.多线程**

一个程序中多个线程同时执行。

### 线程的生命周期

**1.新建状态**

使用new Thread 类或其他子类建立一个线程对象后，该线程对象处于一种新建状态。

**2.就绪状态**

调用start()方法之后，该线程就进入到就绪状态（就绪队列中），等待JVM里线程调度器的调度。

**3.运行状态**

执行run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可变为阻塞状态、就绪状态和死亡状态。

**4.阻塞状态**

如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。

**5.死亡状态**

一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

### 线程调度策略

概念：是指系统为线程分配处理器使用权的过程。

**Java 使用的线程调度是抢占式调度**，在抢占式调度下，优先级最高的任务一直执行，直到它进入等待或死亡状态或更高优先级的任务出现，优先级高的线程比优先级低的线程优先执行。

在Java多线程环境中，为保证所有线程的执行能按照一定的规则执行，JVM实现了一个线程调度器，它定义了线程调度的策略。 在 JVM 中体现为让可运行池中优先级高的线程拥有CPU 使用权。

### 线程之间的通行与协作

**1.sleep()和yield()和join()**



**1）sleep()方法作用**:让当前线程睡眠一段时间，期间不会释放任何持有的锁。

**2） yield()方法作用**：让出该线程的时间片给其它线程。线程调用了yield()方法，表示放弃当前获得的CPU时间片，回到就绪状态。最后由线程调度重新选择就绪状态的线程分配CPU资源。

**3）join()方法作用**：暂停当前线程，等待被调用线程指向结束之后再继续执行。

> **注意：**
>
> 1）sleep(long)方法仅释放CPU使用权，锁仍然占用。
>
> 2）调用join()的时候，当前线程不会释放掉锁。

**2.wait()和notify() 方法和notifyAll()方法**



**1）wait()方法的作用**：让该线程处于等待状态。

**2）notify()方法的作用**：唤醒处于wait的线程。

**3）notifyAll()方法的作用**：唤醒所有处于wait状态的线程。

> 注意：
>
> 1）wait()方法会释放CPU执行权 和 占有的锁。
>
> 2) 线程调用wait()方法后，让该线程处于等待状态。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒。wait和notify必须配套使用，即必须使用同一把锁调用。

